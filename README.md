## Навигация   
[1. Краткое описание](#Description)  
[2. Немного теории](#LittleTheory)  
[3. Алгоритм поворота изображения](#AlgorithmRotationImage)  
[3.1 Поиск новых координат угловых точек (пикселей) изображения при повороте на заданный угол](#SerachCoordinatesCornerPoints)  
[3.2 Вычисление размера новой матрицы, используя найденные координаты](#SizeNewMatrix)  
[3.3 Вычисление новой координаты для каждого пикселя изображения](#CalculationNewCoordinates)  
[3.4 Сглаживание изображения при размещении пикселей](#SmoothingImage)  
[4. Сборка и настройка](#Build)    
[5. Примеры](#Examples)  
  
<a name="Description"><h2>Краткое описание</h2></a>  
(*Проект 2020 года*)  
Программа реализована на языке С++ в среде Microsoft Visual Studio 2019 в виде консольного приложения.  
  
Данная программа осуществляет поворот изображения на угол от 0 до 360 градусов. Пользователю будет необходимо ввести точное наименование(путь) изображения (с его форматом), разрешение которого не превышает 1200 х 1200 пикселей.  
>Пример ввода: «image.jpg» (если изображение располагается в каталоге [rotateImage4](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/tree/master/rotateImage4)). 
   
Далее, будет предложено выбрать направление наклона изображения (по/против часовой), а после ввести угол наклона изображения от 0 до 360 градусов.  
  
После, (если угол наклона не является 0/90/180/270/360) будет предложено выбрать цвет фона изображения (белый или черный). Измененное изображение будет выведено на экран. При желании пользователь сможет сохранить полученное изображение.  
  
В программе выполняются следующие проверки ввода данных:  
* Считывание несуществующего графического файла;
* Считывание изображения, не удовлетворяющего требованиям по размерам (не более 1200х1200 пикселей);
* Направление поворота;
* Угол наклона;
* Выбор цвета фона;
* Сохранение изображения (да/нет);
* Ввод наименования сохраняемого изображения (“имя.формат”).  


<a name="LittleTheory"><h2>Немного теории</h2></a>  
Прежде, чем перейти к работе с изображением, нужно знать, что из себя представляет графический файл.  
  
Графический файл состоит из двух основных частей: заголовка и собственно данных. В начале заголовка стоят несколько числовых значений, которые указывают спецификацию файла (TIF, BMP и т.д.).  
  
За спецификатором следует основное содержание заголовка, содержащее общие сведения о файле, в том числе, высоту и ширину изображения, его тип (цветное палитровое/«в искусственных цветах» или монохромное полутоновое/«двухградационное»), использовалось ли сжатие данных и т.д. Если файл содержит палитровое изображение, то после заголовка в большинстве случаев (но не всегда!) следует таблица цветов, в соответствии с которой элементам изображения присваиваются значения RGB-троек.  

[Подробнее о структуре графического файла](https://studfile.net/preview/774683/page:12/)  
  
Необходимо учитывать формат изображения, т.к. декодеры различных форматов должны быть выполнены с учетом их специфики.  
  
Например, [JPEG](https://en.wikipedia.org/wiki/JPEG) содержит последовательность маркеров, каждый из которых начинается с байта 0xFF, свидетельствующего о начале маркера, и байта-идентификатора. Некоторые маркеры состоят только из этой пары байтов, другие же содержат дополнительные данные, состоящие из двухбайтового поля с длиной информационной части маркера (включая длину этого поля, но за вычетом двух байтов начала маркера, то есть 0xFF и идентификатора) и собственно данных. Такая структура файла позволяет быстро отыскать маркер с необходимыми данными (например, с длиной строки, числом строк и числом цветовых компонентов сжатого изображения).  
  
*Общие маркеры JPEG*  
**Marker Name** | **Marker Identifier** | **Description** |
:-------------: | :-------------------: | :-------------: |
SOI | 0xd8 | Start of Image |  
APP0 | 0xe0 | JFIF application segment |  
APPn | 0xe1 - 0xef | Other APP segments |
DQT | 0xdb | Quantization Table |  
SOF0 | 0xc0 | Start of Frame |  
DHT | 0xc4 | Huffman Table |  
SOS | 0xda | Start of Scan |  
EOI | 0xd9 | End of Image |  
  
Таким образом, для решения поставленной задачи требуется получить из файла палитру цветов, которая будет представлена в виде массива пикселей, образующих матрицу. И, поскольку, для каждого формата изображения требуется свой декодер, то целесообразным будет использование готового решения для считывания/загрузки изображений. В данной программе будет использоваться библиотека OpenCV.  
  
Из OpenCV были использованы следующие функции:  
```C++
Mat loadImage = imread(nameImage, IMREAD_COLOR) – чтение данных из графического файла, где:  
nameImage – имя файла, IMREAD_COLOR - загружает изображение в формате BGR.
```
```C++
pixel[i][j].blue = image.at<Vec3b>(i, j)[0] – перезапись (копирование) данных о цвете blue  
в пикселе из OpenCV в массив для дальнейшей обработки данных без использования данной  
библиотеки. Для цветов green/red операция такая же (различие лишь в индексе – [1], [2]).  
  
Здесь тип Vec3b – вектор с 3-байтовыми записями. Эти байтовые записи являются значениями  
без знака для представления значений в диапазоне от 0 до 255.
```
```C++
imwrite(nameImage, rotateImage) – запись данных в графический файл.
```
  
[Подробнее об операциях над изображениями в OpenCV](https://docs.opencv.org/2.4/doc/user_guide/ug_mat.html)
  
Все дальнейшие действия будут производиться только с полученной матрицей. И для реализации алгоритма поворота изображения была взята за основу [матрица поворота](https://en.wikipedia.org/wiki/Rotation_matrix#In_two_dimensions), конечный вид которой в 2d пространстве будет выглядеть так:  
>![equation](https://latex.codecogs.com/svg.image?%5Cbegin%7Bmatrix%7Dx'%20=%20xcos%5Ctheta%20-%20ysin%5Ctheta%20%5C%5C%20y'%20=%20xsin%5Ctheta%20&plus;%20ycos%5Ctheta%5Cend%7Bmatrix%7D%20)  

>, где x и у – текущая координата точки, θ – угол поворота в радианах, x’ и y’ – координата точки после поворота.  
  
Подробнее рассмотрим данный поворот в следующем разделе.  
<a name="AlgorithmRotationImage"><h2>Алгоритм поворота изображения</h2></a>  
Был разработан алгоритм поворота изображения на произвольный угол, который включает в себя следующие действия:  
1. Поиск новых координат угловых точек (пикселей) изображения при повороте на заданный угол;
2. Вычисление размера новой матрицы, используя найденные координаты;
3. Вычисление новой координаты для каждого пикселя изображения;
4. Сглаживание изображения при размещении пикселей.  
  
Прототип функции для поворота:  
```C++
void rotateImage(pixelRGB **pixel, int angle, float rad, int rows, int cols);
```
  
В функцию для поворота поступают данные, полученные при считывании изображения [cat.jpg](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/cat.jpg), а именно: цветовая палитра, угол поворота (в градусах и радианах), высота и ширина изображения.  
  
Разберем каждый пункт данного алгоритма.  

<a name="SerachCoordinatesCornerPoints"><h2>Поиск новых координат угловых точек (пикселей) изображения при повороте на заданный угол</h2></a>  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/graphic1.png "Изображение, поступившее в функцию")  
Мы имеем четыре точки (x1…x4), в которых будут достигаться максимальные и минимальные значения в строках и столбцах исходной матрицы.  
  
Если совершить поворот в данной системе координат, относительно центра изображения, то значения координат углов выйдут за пределы возможного размера исходной матрицы (Изображение ниже).  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/graphic2.png "Изменение положения углов изображения при повороте")  
Поэтому необходимо вычислить значения в каждой точке, чтобы узнать размер новой матрицы. При этом необходимо учитывать угол поворота, т.к. максимальные и минимальные значения, при определенном угле, будут различны.  
  
Формулы для вычисления максимальных и минимальных значений строк и столбцов, при повороте на заданный угол относительно центра, выглядят следующим образом (основаны на формуле, представленной в конце [раздела 2](https://github.com/1i10/rotation-of-the-image-by-a-given-angle#LittleTheory)):  
>![eqution](https://latex.codecogs.com/svg.image?%5Cbegin%7Bmatrix%7DRow:%20X'%20=%20x0&plus;(x-x0)*cos(a)-(y-y0)*sin(a)%5C%5CColumn:%20Y'%20=%20y0&plus;(y-y0)*cos(a)&plus;(x-x0)*sin(a)%5Cend%7Bmatrix%7D%20)  
  
>, где: x0, y0 – центральные точки, относительно которых происходит вращение; x, y – исходные точки; а – угол поворота в радианах; x’, y’ – координата точки после поворота.  
  
Построим таблицу, в которой покажем какие углы изображения будут максимальными и минимальными при повороте на –нный угол.  

*Значения координат для поворота на заданный угол*  
**Угол поворота** | **0° ≤ angle ≤ 90°** | **90° < angle ≤ 180°** | **180° < angle ≤ 270°** | **270° < angle ≤ 360°** |
:---------------: | :------------------: | :--------------------: | :---------------------: | :---------------------: |  
**Макс. строка** | pixel[rows][0] | pixel[0][0] | pixel[0][cols] | pixel[rows][cols] |  
**Макс. столбец** | pixel[rows][cols] | pixel[rows][0] | pixel[0][0] | pixel[0][cols] |  
**Миним. строка** | pixel[0][cols] | pixel[rows][cols] | pixel[rows][0] | pixel[0][0] |  
**Миним. столбец** | pixel[0][0] | pixel[0][cols] | pixel[rows][cols] | pixel[rows][cols] |  

Здесь *pixel[rows][cols]* – матрица, которая хранит цветовые значения в каждом пикселе;  
*rows* и *cols* – высота и ширина исходного изображения.  
  
Тогда, например, формулы для расчета максимальных и минимальных значений для строк и столбцов при повороте на 60° будут выглядеть так:  
>![equation](https://latex.codecogs.com/svg.image?%5Cbegin%7Bmatrix%7DmaxRow%20=%20centRow%20&plus;%20(rows%20-%20centRow)%20*%20cos(rad)%20-%20(0%20-%20centCol)%20*%20sin(rad)%5C%5CmaxCol%20=%20centCol%20&plus;%20(cols%20-%20centCol)%20*%20cos(rad)%20&plus;%20(rows%20-%20centRow)%20*%20sin(rad)%5C%5CminRow%20=%20centRow%20&plus;%20(0%20-%20centRow)%20*%20cos(rad)%20-%20(cols%20-%20centCol)%20*%20sin(rad)%5C%5CminCol%20=%20centCol%20&plus;%20(0%20-%20centCol)%20*%20cos(rad)%20&plus;%20(0%20-%20centRow)%20*%20sin(rad)%5Cend%7Bmatrix%7D%20)  
  
<a name="SizeNewMatrix"><h2>Вычисление размера новой матрицы, используя найденные координаты</h2></a>  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/graphic3.png "Размер новой матрицы (синее поле)")  
  
По изображению выше можно заметить, что для того, чтобы узнать размер матрицы, необходимо знать минимальное и максимальное значение строк и столбцов. При этом будет получаться так, что минимальные значения будут отрицательными, т.к. были вычислены по исходной матрице. Это следует учитывать.  
  
Тогда формулы для расчета размера матрицы примут вид:  
>![equation](https://latex.codecogs.com/svg.image?%5Cbegin%7Bmatrix%7Dr%20=%20maxRow%20-%20minRow%20&plus;%201%5C%5Cc%20=%20maxCol%20-%20minCol%20&plus;%201%5Cend%7Bmatrix%7D)  
  
>Здесь необходимо было добавить + 1, т.к. нулевую координату тоже следует учитывать из-за отрицательных значений.  
  
Таким образом, будет заведена новая матрица *pixelNew[r][c]*.  

<a name="CalculationNewCoordinates"><h2>Вычисление новой координаты для каждого пикселя изображения</h2></a>  
Перед тем, как начать вычислять новые координаты каждого пикселя изображения, необходимо сравнить количество строк и столбцов исходной и новой матрицы. Для чего это нужно?  
  
Может возникнуть такая ситуация, что количество строк или столбцов будет меньше исходных размеров. Это, например, может произойти, если, допустим, изображение [cat.jpg](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/cat.jpg), размер которого 600х400 пикселей, повернуть на 90/270°. Тогда нужно будет изменить количество пробегов, чтобы были вычислены все новые координаты пикселей.  
  
Далее, будут определены новые координаты для каждого пикселя по уже известной формуле:  
>![equation](https://latex.codecogs.com/svg.image?%5Cbegin%7Bmatrix%7Dx%20=%20centRow%20&plus;%20(i%20-%20centRow)%20*%20cos(rad)%20-%20(j%20-%20centCol)%20*%20sin(rad)%5C%5Cy%20=%20centCol%20&plus;%20(j%20-%20centCol)%20*%20cos(rad)%20&plus;%20(i%20-%20centRow)%20*%20sin(rad)%5Cend%7Bmatrix%7D)  
  
Поскольку, данные значения вычисляются по исходной матрице, необходимо выполнить сдвиг в область новой матрицы. Тогда результирующие значения координат примут вид:  
>![equation](https://latex.codecogs.com/svg.image?%5Cbegin%7Bmatrix%7DnewI%20=%20x%20-%20minRow%5C%5CnewJ%20=%20y%20-%20minCol%5Cend%7Bmatrix%7D)  
  
И, уже после определения координаты, новая матрица примет цветовые значения, хранящиеся в исходной матрице.  

<a name="SmoothingImage"><h2>Сглаживание изображения при размещении пикселей</h2></a>  
Данная операция не нужна, если изображение поворачивается на 0/90/180/270/360°. Но при повороте на иные градусы, изображение примет вид как на рисунке ниже (без сглаживания).  
  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/pixeldot.jpg "Повернутое изображение без операции сглаживания")  
В таком случае необходимо выполнить сдвиг пикселей сразу же после вычисления новой координаты точки.  
  
Сдвиги будут осуществляться в определенную сторону в зависимости от угла поворота. Если угол от 0 до 180°, то сдвиг идет в левую сторону, иначе – в правую.  
  
Допустим, взглянем на изображение выше. Новые координаты, вычисленные на каждом шаге, будут начинать выставляться на позиции с левой стороны. И т.к. каждый последующий вычисленный пиксель матрицы будет располагаться правее уже вычисленных позиций, то сдвиг нужно делать в лево. Поэтому первая строка и столбец будут выставляться без сдвигов.  
  
Исходя из выше сказанного, могут возникнуть три ситуации: 
  
a) Предыдущий пиксель является не пустым. Сдвиг не нужен;  
b) Предыдущий пиксель является пустым;  
c) Есть брешь, возникшая при вычислении координат первой строки/столбца.  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/pixelsPosition.png "Ситуации при размещении пикселей")  
Далее, при смещении, пиксель получает новую координату.  
  
Итоговый результат будет представлен в [разделе 5](https://github.com/1i10/rotation-of-the-image-by-a-given-angle#Examples).  

<a name="Build"><h2>Сборка и настройка</h2></a>  
1. Загрузить проект на локальную машину, например, воспользовавшись командой git clone  
2. Установить библиотеку OpenCV
* Перейти по [ссылке](https://github.com/opencv/opencv/releases/tag/4.1.2)
* Скачать файл *opencv-4.1.2-vc14_vc15.exe*  
* Распаковать скачанный архив  
3. Указать путь до каталога *bin* в переменных среды  
*Для Windows 10:*  
* Перейти в *Парметры*, нажав на шестеренку в меню *Пуск*  
* Ввести в верхнюю строку поиска "Система"  и нажать на соотвествующую запись  
* Перейти в *Дополнительные параметры системы* 
* Во вкладке *Дополнительно* перейти в *Переменные среды*  
* В *Системные переменные* добавить (создать) путь до каталога bin  
>Например, C:\opencv\build\x64\vc14\bin  
  
4. Открыть проект rotateImage4.sln в Microsoft Visual Studio  
5. В свойствах к проекту: перейти *Свойства конфигурации* → *C/C++* → *Общие* → *Дополнительные каталоги включаемых файлов* и указать путь до заголовков OpenCV (build/include)
>Например, C:\opencv\build\include  
  
6. В свойствах к проекту: перейти *Свойства конфигурации* → *Компоновщик* → *Общие* → *Дополнительные каталоги библиотек* и указать путь до расположения файлов библиотеки  
>Например, C:\opencv\build\x64\vc14\lib  

7. В свойствах к проекту: перейти *Свойства конфигурации* → *Компоновщик* → *Ввод* → *Дополнительные зависимости* и вставить название файла *opencv_world412d.lib*  
8. Собрать решение в обозревателе   
9. Вставить в каталог *...\rotation-of-the-image-by-a-given-angle\x64\Debug* файл *opencv_world412d.dll*, который располагается в каталоге OpenCV *..\build\x64\vc14\bin*  

Проект готов к запуску.  

<a name="Examples"><h2>Примеры</h2></a>  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/startConsoleApp.png "Старт программы")  
Попробуем загрузить несуществующее изображение и изображение, которое не удовлетворяет условиям размера.  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/uncorrectInput.png "Считывание некорректного графического файла")  
Теперь загрузим изображение “[cat.jpg](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/cat.jpg)”. Если данные графического файла были успешно считаны, то будет предложено выбрать направление, при котором будет осуществляться наклон изображения. Выполним поворот против часовой стрелки.  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/choiceOfDirection.png "Выбор направления наклона")  
После нужно будет ввести угол наклона изображения. Совершим поворот на 60°.  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/inputAngle.png "Ввод угла наклона изображения")  
Теперь следует выбрать цвет фона. Сделаем черный фон для изображения [cat.jpg](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/cat.jpg). После будет выведено на экран, полученное изображение при повороте на 60°.  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/output.png "Вывод на экран повернутого изображения")  
Для продолжения и последующего сохранения изображения требуется закрыть выведенное изображение (нажать крестик).  
  
Далее, будет предложено сохранить изображение. Пользователю необходимо ввести наименование, сохраняемого изображения, которое должно соответствовать установленным требованиям (наименование без русских символов и поддерживаемого формата: bmp, jpeg, jpg, png). При выполнении всех условий изображение будет сохранено на компьютер.  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/saveImage.png "Сохранение изображения на компьютер")  
  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/catSam.png "Сохраненное изображение, повернутое на 60° против часовой стрелки")  
  
Совершим еще несколько поворотов для изображения [cat2.png](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/cat2.png).  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/1.png "Поворот на 133° по часовой")  
  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/2.png "Поворот на 90° против часовой")  
  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/3.png "Поворот на 15° по часовой")  
  
![image](https://github.com/1i10/rotation-of-the-image-by-a-given-angle/blob/master/rotateImage4/ExamplesImages/4.png "Поворот на 140° против часовой")  



